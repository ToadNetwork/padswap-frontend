"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Copyright 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the “License”);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// <https://apache.org/licenses/LICENSE-2.0>.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an “AS IS” BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// https://github.com/GoogleChromeLabs/jsbi#how
var binaryFunctionToExpression = new Map([['add', '+'], ['subtract', '-'], ['multiply', '*'], ['divide', '/'], ['remainder', '%'], ['exponentiate', '**'], ['leftShift', '<<'], ['signedRightShift', '>>'], ['bitwiseAnd', '&'], ['bitwiseOr', '|'], ['bitwiseXor', '^'], ['equal', '==='], ['notEqual', '!=='], ['lessThan', '<'], ['lessThanOrEqual', '<='], ['greaterThan', '>'], ['greaterThanOrEqual', '>='], ['EQ', '=='], ['NE', '!='], ['LT', '<'], ['LE', '<='], ['GT', '>'], ['GE', '>='], ['ADD', '+']]); // https://github.com/GoogleChromeLabs/jsbi#how

var unaryFunctionToExpression = new Map([['unaryMinus', '-'], ['bitwiseNot', '~']]); // https://github.com/GoogleChromeLabs/jsbi#how

var staticMethods = new Set(['asIntN', 'asUintN']);
var DATA_IDENTIFIER = 'JSBI';

function _default(babel) {
  var t = babel.types;

  var createExpression = function createExpression(path, name, args) {
    if (name === 'BigInt') {
      return createBigIntConstructor(path);
    }

    if (binaryFunctionToExpression.has(name)) {
      if (args.length !== 2) {
        throw path.buildCodeFrameError('Binary operators must have exactly two arguments');
      }

      return t.binaryExpression(binaryFunctionToExpression.get(name), args[0], args[1]);
    }

    if (unaryFunctionToExpression.has(name)) {
      if (args.length !== 1) {
        throw path.buildCodeFrameError('Unary operators must have exactly one argument');
      }

      return t.unaryExpression(unaryFunctionToExpression.get(name), args[0]);
    }

    if (staticMethods.has(name)) {
      if (args.length !== 2) {
        throw path.buildCodeFrameError('Static methods must have exactly two arguments');
      }

      return t.callExpression(t.memberExpression(t.identifier('BigInt'), t.identifier(name)), args);
    }

    if (name === 'toNumber') {
      if (args.length !== 1) {
        throw path.buildCodeFrameError('toNumber must have exactly one argument');
      }

      return t.callExpression(t.identifier('Number'), args);
    }

    throw path.buildCodeFrameError("Unknown JSBI function '".concat(name, "'"));
  };

  var createBigIntConstructor = function createBigIntConstructor(path) {
    var reInteger = /^(?:0|[1-9][0-9]*)$/;
    var arg = path.node.arguments[0];

    if (t.isNumericLiteral(arg) || t.isStringLiteral(arg) && reInteger.test(arg.value)) {
      return t.bigIntLiteral("".concat(arg.value));
    }

    return t.callExpression(t.identifier('BigInt'), [arg]);
  };

  var getPropertyName = function getPropertyName(path) {
    var node = path.node;
    if (t.isIdentifier(node)) return node.name;
    if (t.isStringLiteral(node)) return node.value;
    throw path.buildCodeFrameError('Only .BigInt or [\'BigInt\'] allowed here.');
  };

  var resolveBinding = function resolveBinding(_path, name) {
    var binding = _path.scope.getBinding(name);

    if (binding === undefined) return;
    var path = binding.path;
    if (path.getData(DATA_IDENTIFIER)) return binding;
    var init = path.node.init;

    if (t.isVariableDeclarator(path) && t.isMemberExpression(init)) {
      return resolveBinding(path.get('init'), init.object.name);
    }

    return binding;
  };

  var getJSBIProperty = function getJSBIProperty(path, name) {
    var binding = resolveBinding(path, name);
    return binding && binding.path.getData(DATA_IDENTIFIER);
  };

  var setJSBIProperty = function setJSBIProperty(path, data) {
    return path.setData(DATA_IDENTIFIER, data);
  };

  var hasJSBIProperty = function hasJSBIProperty(path, name) {
    return getJSBIProperty(path, name) !== undefined;
  };

  return {
    pre: function pre() {
      this.remove = new Set();
    },
    visitor: {
      Program: {
        exit: function exit() {
          var _iterator = _createForOfIteratorHelper(this.remove),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var path = _step.value;
              path.remove();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      },
      ImportDeclaration: function ImportDeclaration(path) {
        var source = path.node.source;

        if (t.isStringLiteral(source) && ( // Match exact "jsbi" or ".../jsbi.mjs" paths.
        /^jsbi$/i.test(source.value) || /[/\\]jsbi\.mjs$/i.test(source.value))) {
          var _iterator2 = _createForOfIteratorHelper(path.get('specifiers')),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var specifier = _step2.value;

              if (t.isImportDefaultSpecifier(specifier)) {
                setJSBIProperty(specifier, '');
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          this.remove.add(path);
        }
      },
      VariableDeclarator: function VariableDeclarator(path) {
        var init = path.node.init;

        if (t.isMemberExpression(init)) {
          if (hasJSBIProperty(path, init.object.name)) {
            setJSBIProperty(path, getPropertyName(path.get('init.property')));
            this.remove.add(path);
          }
        }
      },
      CallExpression: function CallExpression(path) {
        var callee = path.node.callee;

        if (t.isMemberExpression(callee) && hasJSBIProperty(path, callee.object.name)) {
          // Handle usage via `JSBI.foo(bar)`.
          path.replaceWith(createExpression(path, getPropertyName(path.get('callee.property')), path.node.arguments));
        } else {
          // Handle usage via `JSBigInt = JSBI.BigInt; JSBigInt(foo)`.
          var jsbiProp = getJSBIProperty(path, callee.name);

          if (jsbiProp) {
            path.replaceWith(createExpression(path, jsbiProp, path.node.arguments));
          }
        }
      },
      BinaryExpression: function BinaryExpression(path) {
        var _path$node = path.node,
            operator = _path$node.operator,
            left = _path$node.left,
            right = _path$node.right;

        if (operator === 'instanceof' && t.isIdentifier(right, {
          name: 'JSBI'
        })) {
          path.replaceWith(t.binaryExpression('===', t.unaryExpression('typeof', left), t.stringLiteral('bigint')));
        }
      }
    }
  };
}